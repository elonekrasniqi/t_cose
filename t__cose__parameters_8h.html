<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>t_cose: inc/t_cose/t_cose_parameters.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">t_cose
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bfccd401955b95cf8c75461437045ac0.html">inc</a></li><li class="navelem"><a class="el" href="dir_c790dd4d93afe6413732f56f53ec2af4.html">t_cose</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">t_cose_parameters.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Parameter encoding and decoding.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;C:/Users/ADMIN/QCBOR/inc/qcbor/qcbor.h&quot;</code><br />
<code>#include &quot;C:/Users/ADMIN/t_cose/inc/t_cose/q_useful_buf.h&quot;</code><br />
<code>#include &quot;C:/Users/ADMIN/t_cose/inc/t_cose/t_cose_common.h&quot;</code><br />
<code>#include &quot;C:/Users/ADMIN/t_cose/inc/t_cose/t_cose_standard_constants.h&quot;</code><br />
<code>#include &quot;C:/Users/ADMIN/t_cose/inc/t_cose/t_cose_key.h&quot;</code><br />
</div>
<p><a href="t__cose__parameters_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__cose__param__special__encode.html">t_cose_param_special_encode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__cose__param__special__decode.html">t_cose_param_special_decode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__cose__header__location.html">t_cose_header_location</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__cose__parameter.html">t_cose_parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__cose__parameters.html">t_cose_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__cose__parameter__storage.html">t_cose_parameter_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a739f7444f69c4abd87ad3fed318a3615" id="r_a739f7444f69c4abd87ad3fed318a3615"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a739f7444f69c4abd87ad3fed318a3615">T_COSE_MAX_CRITICAL_PARAMS</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a739f7444f69c4abd87ad3fed318a3615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cee8df9869557ac49e8436939f920f8" id="r_a1cee8df9869557ac49e8436939f920f8"><td class="memItemLeft" align="right" valign="top"><a id="a1cee8df9869557ac49e8436939f920f8" name="a1cee8df9869557ac49e8436939f920f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>T_COSE_PARAMETER_TYPE_NONE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a1cee8df9869557ac49e8436939f920f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f94bccd122c154a9c28a4106019a01c" id="r_a3f94bccd122c154a9c28a4106019a01c"><td class="memItemLeft" align="right" valign="top"><a id="a3f94bccd122c154a9c28a4106019a01c" name="a3f94bccd122c154a9c28a4106019a01c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>T_COSE_PARAMETER_TYPE_INT64</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a3f94bccd122c154a9c28a4106019a01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96be90a6030dcd66cc12d952f593ad4f" id="r_a96be90a6030dcd66cc12d952f593ad4f"><td class="memItemLeft" align="right" valign="top"><a id="a96be90a6030dcd66cc12d952f593ad4f" name="a96be90a6030dcd66cc12d952f593ad4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>T_COSE_PARAMETER_TYPE_BYTE_STRING</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a96be90a6030dcd66cc12d952f593ad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af928d051e4cbefd479c3102cedd85783" id="r_af928d051e4cbefd479c3102cedd85783"><td class="memItemLeft" align="right" valign="top"><a id="af928d051e4cbefd479c3102cedd85783" name="af928d051e4cbefd479c3102cedd85783"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>T_COSE_PARAMETER_TYPE_TEXT_STRING</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:af928d051e4cbefd479c3102cedd85783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87fe9097894631d40ecd94c0b4fbff0" id="r_ae87fe9097894631d40ecd94c0b4fbff0"><td class="memItemLeft" align="right" valign="top"><a id="ae87fe9097894631d40ecd94c0b4fbff0" name="ae87fe9097894631d40ecd94c0b4fbff0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>T_COSE_PARAMETER_TYPE_SPECIAL</b>&#160;&#160;&#160;100</td></tr>
<tr class="separator:ae87fe9097894631d40ecd94c0b4fbff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3f10122accf3f67342cfc1b01efe29" id="r_a7c3f10122accf3f67342cfc1b01efe29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a7c3f10122accf3f67342cfc1b01efe29">T_COSE_EMPTY_UINT_CONTENT_TYPE</a>&#160;&#160;&#160;UINT16_MAX+1</td></tr>
<tr class="separator:a7c3f10122accf3f67342cfc1b01efe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af979ab07813f2f71b575b468ade54b37" id="r_af979ab07813f2f71b575b468ade54b37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#af979ab07813f2f71b575b468ade54b37">T_COSE_PARAM_STORAGE_INIT</a>(p_storage,  p_array)</td></tr>
<tr class="separator:af979ab07813f2f71b575b468ade54b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d3282978b24d425b9a1066e050e08c9" id="r_a5d3282978b24d425b9a1066e050e08c9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a5d3282978b24d425b9a1066e050e08c9">t_cose_param_special_encode_cb</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter, QCBOREncodeContext *cbor_encoder)</td></tr>
<tr class="memdesc:a5d3282978b24d425b9a1066e050e08c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of callback to output the encoded CBOR of a special parameter.  <br /></td></tr>
<tr class="separator:a5d3282978b24d425b9a1066e050e08c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14704cc3462c82fedfcc45682af0829" id="r_ab14704cc3462c82fedfcc45682af0829"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#ab14704cc3462c82fedfcc45682af0829">t_cose_param_special_decode_cb</a> (void *cb_context, QCBORDecodeContext *cbor_decoder, struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter)</td></tr>
<tr class="memdesc:ab14704cc3462c82fedfcc45682af0829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of callback to decode a special parameter.  <br /></td></tr>
<tr class="separator:ab14704cc3462c82fedfcc45682af0829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9761c126c6e6ae2562c229e2714bc904" id="r_a9761c126c6e6ae2562c229e2714bc904"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a9761c126c6e6ae2562c229e2714bc904">t_cose_headers_encode</a> (QCBOREncodeContext *cbor_encoder, const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameters, struct q_useful_buf_c *protected_parameters)</td></tr>
<tr class="memdesc:a9761c126c6e6ae2562c229e2714bc904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode both the protected and unprotected header buckets.  <br /></td></tr>
<tr class="separator:a9761c126c6e6ae2562c229e2714bc904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac64bf4f4f01396858cfc294d492587d" id="r_aac64bf4f4f01396858cfc294d492587d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#aac64bf4f4f01396858cfc294d492587d">t_cose_headers_decode</a> (QCBORDecodeContext *cbor_decoder, const struct <a class="el" href="structt__cose__header__location.html">t_cose_header_location</a> location, <a class="el" href="t__cose__parameters_8h.html#ab14704cc3462c82fedfcc45682af0829">t_cose_param_special_decode_cb</a> *special_decode_cb, void *special_decode_ctx, struct <a class="el" href="structt__cose__parameter__storage.html">t_cose_parameter_storage</a> *parameter_storage, struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> **decoded_params, struct q_useful_buf_c *protected_parameters)</td></tr>
<tr class="memdesc:aac64bf4f4f01396858cfc294d492587d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode protected and unprotected header buckets.  <br /></td></tr>
<tr class="separator:aac64bf4f4f01396858cfc294d492587d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1f9c9e9382896caa2aaa0e0e3d217a" id="r_aae1f9c9e9382896caa2aaa0e0e3d217a"><td class="memItemLeft" align="right" valign="top"><a id="aae1f9c9e9382896caa2aaa0e0e3d217a" name="aae1f9c9e9382896caa2aaa0e0e3d217a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>t_cose_params_empty</b> (struct q_useful_buf_c encoded_params)</td></tr>
<tr class="separator:aae1f9c9e9382896caa2aaa0e0e3d217a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f72a09565b68f445ae66d346a0572e" id="r_a97f72a09565b68f445ae66d346a0572e"><td class="memItemLeft" align="right" valign="top"><a id="a97f72a09565b68f445ae66d346a0572e" name="a97f72a09565b68f445ae66d346a0572e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>t_cose_params_empty_bstr</b> (struct q_useful_buf_c encoded_params)</td></tr>
<tr class="separator:a97f72a09565b68f445ae66d346a0572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69809f33c0f929be028849642c0b186c" id="r_a69809f33c0f929be028849642c0b186c"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a69809f33c0f929be028849642c0b186c">t_cose_params_check</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameters)</td></tr>
<tr class="memdesc:a69809f33c0f929be028849642c0b186c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check parameter list, particularly for unknown critical parameters.  <br /></td></tr>
<tr class="separator:a69809f33c0f929be028849642c0b186c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5421930f23872fb1cbc2cba4c48e6774" id="r_a5421930f23872fb1cbc2cba4c48e6774"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a5421930f23872fb1cbc2cba4c48e6774">t_cose_params_append</a> (struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> **existing, struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *to_be_appended)</td></tr>
<tr class="memdesc:a5421930f23872fb1cbc2cba4c48e6774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append one list of parameters to another.  <br /></td></tr>
<tr class="separator:a5421930f23872fb1cbc2cba4c48e6774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545129eca5ab20de90a5b3b4d3aff5ed" id="r_a545129eca5ab20de90a5b3b4d3aff5ed"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a545129eca5ab20de90a5b3b4d3aff5ed">t_cose_param_make_alg_id</a> (int32_t alg_id)</td></tr>
<tr class="separator:a545129eca5ab20de90a5b3b4d3aff5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4ac226cdc427d38138eb17e928ccc3" id="r_aac4ac226cdc427d38138eb17e928ccc3"><td class="memItemLeft" align="right" valign="top"><a id="aac4ac226cdc427d38138eb17e928ccc3" name="aac4ac226cdc427d38138eb17e928ccc3"></a>
static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>t_cose_param_make_unprot_alg_id</b> (int32_t alg_id)</td></tr>
<tr class="separator:aac4ac226cdc427d38138eb17e928ccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0291e4008cf4ee528dfe9fd0c854ed7c" id="r_a0291e4008cf4ee528dfe9fd0c854ed7c"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a0291e4008cf4ee528dfe9fd0c854ed7c">t_cose_param_make_ct_uint</a> (uint32_t content_type)</td></tr>
<tr class="separator:a0291e4008cf4ee528dfe9fd0c854ed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7a84ecdd2d3638ad43228271f40f6b" id="r_a3f7a84ecdd2d3638ad43228271f40f6b"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a3f7a84ecdd2d3638ad43228271f40f6b">t_cose_param_make_ct_tstr</a> (struct q_useful_buf_c content_type)</td></tr>
<tr class="separator:a3f7a84ecdd2d3638ad43228271f40f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81088452143eca66114cd3ccfc28aa29" id="r_a81088452143eca66114cd3ccfc28aa29"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a81088452143eca66114cd3ccfc28aa29">t_cose_param_make_kid</a> (struct q_useful_buf_c kid)</td></tr>
<tr class="separator:a81088452143eca66114cd3ccfc28aa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfc6c35ec52d2ef7150bdfaa9d163d7" id="r_a6bfc6c35ec52d2ef7150bdfaa9d163d7"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a6bfc6c35ec52d2ef7150bdfaa9d163d7">t_cose_param_make_iv</a> (struct q_useful_buf_c iv)</td></tr>
<tr class="separator:a6bfc6c35ec52d2ef7150bdfaa9d163d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15cddff6d474ac7d7d0f1d85a1e7b7a" id="r_ad15cddff6d474ac7d7d0f1d85a1e7b7a"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#ad15cddff6d474ac7d7d0f1d85a1e7b7a">t_cose_param_make_partial_iv</a> (struct q_useful_buf_c iv)</td></tr>
<tr class="separator:ad15cddff6d474ac7d7d0f1d85a1e7b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ad9cfbcc500c4b4276b82ede197fcb" id="r_aa3ad9cfbcc500c4b4276b82ede197fcb"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#aa3ad9cfbcc500c4b4276b82ede197fcb">t_cose_param_find</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list, int64_t label)</td></tr>
<tr class="memdesc:aa3ad9cfbcc500c4b4276b82ede197fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a parameter by label in linked list.  <br /></td></tr>
<tr class="separator:aa3ad9cfbcc500c4b4276b82ede197fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b2a5799a704143168a4ad232f8c1e5" id="r_ab2b2a5799a704143168a4ad232f8c1e5"><td class="memItemLeft" align="right" valign="top"><a id="ab2b2a5799a704143168a4ad232f8c1e5" name="ab2b2a5799a704143168a4ad232f8c1e5"></a>
struct q_useful_buf_c&#160;</td><td class="memItemRight" valign="bottom"><b>t_cose_param_find_bstr</b> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list, int64_t label)</td></tr>
<tr class="separator:ab2b2a5799a704143168a4ad232f8c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ccad34fa1eccefc8d2d939c3bb79bf" id="r_ad3ccad34fa1eccefc8d2d939c3bb79bf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#ad3ccad34fa1eccefc8d2d939c3bb79bf">t_cose_param_find_alg_id</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list, bool *prot)</td></tr>
<tr class="memdesc:ad3ccad34fa1eccefc8d2d939c3bb79bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the algorithm ID parameter in a linked list.  <br /></td></tr>
<tr class="separator:ad3ccad34fa1eccefc8d2d939c3bb79bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f74f4cc698ba68963cbe130be77da6c" id="r_a9f74f4cc698ba68963cbe130be77da6c"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a9f74f4cc698ba68963cbe130be77da6c">t_cose_param_find_alg_id_prot</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list)</td></tr>
<tr class="memdesc:a9f74f4cc698ba68963cbe130be77da6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the protected algorithm ID parameter in a linked list.  <br /></td></tr>
<tr class="separator:a9f74f4cc698ba68963cbe130be77da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612af7647cdaa346f74948d1c3334e36" id="r_a612af7647cdaa346f74948d1c3334e36"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a612af7647cdaa346f74948d1c3334e36">t_cose_param_find_alg_id_unprot</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list)</td></tr>
<tr class="memdesc:a612af7647cdaa346f74948d1c3334e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the unprotected algorithm ID parameter in a linked list.  <br /></td></tr>
<tr class="separator:a612af7647cdaa346f74948d1c3334e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f41b741c3745ae2b8611a6e8b75b9dc" id="r_a3f41b741c3745ae2b8611a6e8b75b9dc"><td class="memItemLeft" align="right" valign="top">struct q_useful_buf_c&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a3f41b741c3745ae2b8611a6e8b75b9dc">t_cose_param_find_content_type_tstr</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list)</td></tr>
<tr class="memdesc:a3f41b741c3745ae2b8611a6e8b75b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the text string content type parameter in a linked list.  <br /></td></tr>
<tr class="separator:a3f41b741c3745ae2b8611a6e8b75b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3d3bd6a38321cb4e792c325fceec51" id="r_acd3d3bd6a38321cb4e792c325fceec51"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#acd3d3bd6a38321cb4e792c325fceec51">t_cose_param_find_content_type_uint</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list)</td></tr>
<tr class="memdesc:acd3d3bd6a38321cb4e792c325fceec51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the CoAP content type parameter in a linked list.  <br /></td></tr>
<tr class="separator:acd3d3bd6a38321cb4e792c325fceec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff1cc0b353412a8cf5153bd970cd970" id="r_a5ff1cc0b353412a8cf5153bd970cd970"><td class="memItemLeft" align="right" valign="top">struct q_useful_buf_c&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a5ff1cc0b353412a8cf5153bd970cd970">t_cose_param_find_kid</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list)</td></tr>
<tr class="memdesc:a5ff1cc0b353412a8cf5153bd970cd970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key ID (kid) parameter in a linked list.  <br /></td></tr>
<tr class="separator:a5ff1cc0b353412a8cf5153bd970cd970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9509bc8953a0787153594c7f058280" id="r_a1b9509bc8953a0787153594c7f058280"><td class="memItemLeft" align="right" valign="top">struct q_useful_buf_c&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a1b9509bc8953a0787153594c7f058280">t_cose_param_find_iv</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list)</td></tr>
<tr class="memdesc:a1b9509bc8953a0787153594c7f058280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the initialization vector parameter in a linked list.  <br /></td></tr>
<tr class="separator:a1b9509bc8953a0787153594c7f058280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e9d48e702604801b14d2869948343e" id="r_a60e9d48e702604801b14d2869948343e"><td class="memItemLeft" align="right" valign="top">struct q_useful_buf_c&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a60e9d48e702604801b14d2869948343e">t_cose_param_find_partial_iv</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *parameter_list)</td></tr>
<tr class="memdesc:a60e9d48e702604801b14d2869948343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the initialization vector parameter in a linked list.  <br /></td></tr>
<tr class="separator:a60e9d48e702604801b14d2869948343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d908ec137d12d9bd74cec2be72e536" id="r_a95d908ec137d12d9bd74cec2be72e536"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="t__cose__parameters_8h.html#a95d908ec137d12d9bd74cec2be72e536">t_cose_params_common</a> (const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *decoded_params, struct <a class="el" href="structt__cose__parameters.html">t_cose_parameters</a> *returned_params)</td></tr>
<tr class="memdesc:a95d908ec137d12d9bd74cec2be72e536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in structure with common header parameters.  <br /></td></tr>
<tr class="separator:a95d908ec137d12d9bd74cec2be72e536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af727ba68596b8757680ec7e474f7294f" id="r_af727ba68596b8757680ec7e474f7294f"><td class="memItemLeft" align="right" valign="top"><a id="af727ba68596b8757680ec7e474f7294f" name="af727ba68596b8757680ec7e474f7294f"></a>
static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>t_cose_param_make_unprot_bstr</b> (struct q_useful_buf_c string, int32_t label)</td></tr>
<tr class="separator:af727ba68596b8757680ec7e474f7294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parameter encoding and decoding. </p>
<p>Parameter encoding and decoding centers on <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> and functions for encoding and decoding linked lists of it. Users of the t_cose public APIs for verifying signing, encrypting, decrypting and MACing will mainly use struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>, not the encoding and decoding functions.</p>
<p>Struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> holds a single parameter that is to be encoded or has been decoded. The same structure is used for both. Most parameter values are either integers or strings and are held directly in struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>. Parameters that are not integers or strings are special and must be encoded or decoded by a callback. "Special" here is only a characteristic of t_cose not anything in the COSE standard.</p>
<p>Only integer parameter labels are supported (so far).</p>
<p>For many encoding use cases the needed header parameters will be automatically generated and there is no need for use of anything in this file.</p>
<p>When decoding a COSE message (verification, decryption, ...) the full set of header parameters decoded are returned as linked list of struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>. In many cases the caller will not need to examine what is returned.</p>
<p>If the caller wishes to examine them, they can iterate over the linked list searching by label. The data type, protected-ness and criticality of the parameters in the returned list is not checked. It is up to the caller examining these to check. Some functions for examining headers in the array are provided. See t_cose_find_parameter(), t_cose_find_parameter_kid(), etcâ€¦ These do fully check the protected-ness, criticality and type of the parameter.</p>
<p>Some COSE messages, COSE_Sign1, COSE_Mac0 and COSE_Encrypt0 have just one set of headers, those for the main body. Other messages, COSE_Sign, COSE_Encrypt and COSE_Mac, have body headers and additionally headers per recipient or signer. The data structures and functions here handle all of these.</p>
<p>When encoding, multiple header sets are handled in the interface for signing, encrypting and such. There are separate functions for passing in the body header and the header per signer and per recipient.</p>
<p>When decoding, all the headers for the entire message are returned in one list. Each bucket of headers is assigned a location (<a class="el" href="structt__cose__header__location.html">t_cose_header_location</a>) that indicates nesting level and index in the COSE message.</p>
<p>The nodes for the linked lists are allocated out of a pool that is represented by <a class="el" href="structt__cose__parameter__storage.html">t_cose_parameter_storage</a>. It is a very simple allocation scheme that takes nodes out of the pool as the COSE message is decoded. There is not a free operation. The whole pool is just destroyed when all processing on a COSE message is complete. The actual memory for the pool can be allocated by any means, but it is allocated all at once up front.</p>
<p>Each message decoder (e.g., verifier, decryptor) has a small pool built into their context that is enough for simple message. A larger pool can be added for complex messages with lots of parameters. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7c3f10122accf3f67342cfc1b01efe29" name="a7c3f10122accf3f67342cfc1b01efe29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3f10122accf3f67342cfc1b01efe29">&#9670;&#160;</a></span>T_COSE_EMPTY_UINT_CONTENT_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T_COSE_EMPTY_UINT_CONTENT_TYPE&#160;&#160;&#160;UINT16_MAX+1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The value of an unsigned integer content type indicating no content type. See <a class="el" href="structt__cose__parameters.html">t_cose_parameters</a>. </p>

</div>
</div>
<a id="a739f7444f69c4abd87ad3fed318a3615" name="a739f7444f69c4abd87ad3fed318a3615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739f7444f69c4abd87ad3fed318a3615">&#9670;&#160;</a></span>T_COSE_MAX_CRITICAL_PARAMS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T_COSE_MAX_CRITICAL_PARAMS&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of critical header parameters that can be handled during decoding (e.g., during verification, decryption, ...). <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97aa2a158c2198a24c1d22ba3706ff8182b">T_COSE_ERR_TOO_MANY_PARAMETERS</a> will be returned if the input message has more.</p>
<p>There can be both <a class="el" href="t__cose__parameters_8h.html#a739f7444f69c4abd87ad3fed318a3615">T_COSE_MAX_CRITICAL_PARAMS</a> integer-labeled parameters and <a class="el" href="t__cose__parameters_8h.html#a739f7444f69c4abd87ad3fed318a3615">T_COSE_MAX_CRITICAL_PARAMS</a> string-labeled parameters.</p>
<p>This is a hard maximum so the implementation doesn't need malloc. This constant can be increased if needed. Doing so will increase stack usage. </p>

</div>
</div>
<a id="af979ab07813f2f71b575b468ade54b37" name="af979ab07813f2f71b575b468ade54b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af979ab07813f2f71b575b468ade54b37">&#9670;&#160;</a></span>T_COSE_PARAM_STORAGE_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T_COSE_PARAM_STORAGE_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_storage, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_array&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    p_storage.storage = p_array; \</div>
<div class="line">    p_storage.used = 0; \</div>
<div class="line">    p_storage.size = <span class="keyword">sizeof</span>(p_array) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code hl_struct" href="structt__cose__parameter.html">t_cose_parameter</a>)</div>
<div class="ttc" id="astructt__cose__parameter_html"><div class="ttname"><a href="structt__cose__parameter.html">t_cose_parameter</a></div><div class="ttdef"><b>Definition</b> t_cose_parameters.h:247</div></div>
</div><!-- fragment --><p>Macro to initialize parameter storage with some storage provided as an array of struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> that can be used with sizeof(). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aac64bf4f4f01396858cfc294d492587d" name="aac64bf4f4f01396858cfc294d492587d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac64bf4f4f01396858cfc294d492587d">&#9670;&#160;</a></span>t_cose_headers_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a> t_cose_headers_decode </td>
          <td>(</td>
          <td class="paramtype">QCBORDecodeContext *&#160;</td>
          <td class="paramname"><em>cbor_decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__header__location.html">t_cose_header_location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="t__cose__parameters_8h.html#ab14704cc3462c82fedfcc45682af0829">t_cose_param_special_decode_cb</a> *&#160;</td>
          <td class="paramname"><em>special_decode_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>special_decode_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structt__cose__parameter__storage.html">t_cose_parameter_storage</a> *&#160;</td>
          <td class="paramname"><em>parameter_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> **&#160;</td>
          <td class="paramname"><em>decoded_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct q_useful_buf_c *&#160;</td>
          <td class="paramname"><em>protected_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode protected and unprotected header buckets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cbor_decoder</td><td>QCBOR decoder to decode from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>Location in message of the parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">special_decode_cb</td><td>Callback for non-integer and non-string parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">special_decode_ctx</td><td>Context for the above callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_storage</td><td>Storage pool for parameter list nodes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">decoded_params</td><td>Pointer to parameter list to append to or to <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">protected_parameters</td><td>Pointer and length of encoded protected parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>For most COSE message decoding (e.g. verification of a COSE_SIgn1), this is not needed. This is mainly used internally or by implemention of a new <code><a class="el" href="structt__cose__signature__verify.html">t_cose_signature_verify</a></code> or <code>t_cose_recipient_decrypt</code> object.</p>
<p>Use this to decode "Headers" that occurs throughout COSE. The QCBOR decoder should be positioned so the protected header bucket is the next item to be decoded. This then consumes the CBOR for the two header parameter buckets leaving the decoder positioned for what ever comes after.</p>
<p>The decoded headers are put into a linked list the nodes for which are allocated out of <code>parameter_storage</code>. They are appended to the list in <code>*decoded_params</code>. It may be an empty list (e.g., <code>NULL</code>) or a linked list to append to.</p>
<p>In order to handle parameters that are not integers or strings a callback of type special_decode_cb must be given. There is only one of these callbacks for all the non-integer and non-string header parameters. It typically switches on the parameter label.</p>
<p>If <code>no_protected</code> is <code>true</code>, then the protected headers must be an empty byte string. This is used when the cryptographic algorithm used can't protect headers, for example non-AEAD ciphers for COSE encryption.</p>
<p>The crit parameter will be decoded and any parameter label listed in it will be marked as crit in the list returned. It is up to the caller to check the list for crit parameters and error out if they are not processed. See <a class="el" href="t__cose__parameters_8h.html#a69809f33c0f929be028849642c0b186c" title="Check parameter list, particularly for unknown critical parameters.">t_cose_params_check()</a>.</p>
<p>The number of parameters in the crititical parameters parameter is limited to <a class="el" href="t__cose__parameters_8h.html#a739f7444f69c4abd87ad3fed318a3615">T_COSE_MAX_CRITICAL_PARAMS</a> for each bucket of headers. <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97aa2a158c2198a24c1d22ba3706ff8182b">T_COSE_ERR_TOO_MANY_PARAMETERS</a> is returned if this is exceeded and the decode of all the header ends. Note that this only the limit for one header bucket, not the aggregation of all the headers buckets. For example it limits the crit list in for one COSE_Signer, not the the total of all COSE_Signers. This is a hard limit that can only be increased by changing the size and re building the t_cose library. </p>

</div>
</div>
<a id="a9761c126c6e6ae2562c229e2714bc904" name="a9761c126c6e6ae2562c229e2714bc904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9761c126c6e6ae2562c229e2714bc904">&#9670;&#160;</a></span>t_cose_headers_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a> t_cose_headers_encode </td>
          <td>(</td>
          <td class="paramtype">QCBOREncodeContext *&#160;</td>
          <td class="paramname"><em>cbor_encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct q_useful_buf_c *&#160;</td>
          <td class="paramname"><em>protected_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode both the protected and unprotected header buckets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cbor_encoder</td><td>Encoder context for header output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The list of parameters to output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">protected_parameters</td><td>Place to put pointer and length of encoded protected headers. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>For most COSE message creation (e.g., signing a COSE_Sign1), this is not needed. It use is more for implementors of <a class="el" href="structt__cose__signature__sign.html">t_cose_signature_sign</a>.</p>
<p>This encodes COSE "Headers" that are used in COSE_Sign, COSE_Sign1, COSE_Signature, COSE_Encrypt, COSE_Encrypt0, COSE_Mac, COSE_Mac0 and COSE_Recipient.</p>
<p>The input to this is a linked list of struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> containing both protected and unprotected header parameters. They will be encoded and output to the CBOR encoder context first into the protected header bucket and second the unprotected header bucket.</p>
<p>The input set is a linked list through the <code>next</code> member of struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> and ends with a <code>NULL</code> pointer.</p>
<p><code>t_cose_parameter.protected</code> indicates whether the parameter should go into the protected or unprotected bucket. The order of the parameters in the input doesn't matter.</p>
<p>Each parameter has a label, data type and value. Only integer label types are supported (so far). Most header parameters will be either an integer or string, (T_COSE_PARAMETER_TYPE_INT64, T_COSE_PARAMETER_TYPE_BYTE_STRING or T_COSE_PARAMETER_TYPE_TEXT_STRING).</p>
<p>The parameter type may also be T_COSE_PARAMETER_TYPE_SPECIAL in which case the a callback function and context are supplied that will be called when it is time to encode that parameter. This is typically needed for parameter types that are not integers or strings, but can be used for them too.</p>
<p>The crit header parameter will be automatically added if there are any protected parameters that are marked as critical. If there are none, then it will not be added. There is no limit to the number of critical parameters to encode.</p>
<p>A pointer and length of the protected header byte string is returned so that it can be covered by what ever protection mechanism is in used (e.g., hashing or AEAD encryption). If there are no protected header parameters an empty string will always be returned in <code>protected_parameters</code>. </p>

</div>
</div>
<a id="aa3ad9cfbcc500c4b4276b82ede197fcb" name="aa3ad9cfbcc500c4b4276b82ede197fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ad9cfbcc500c4b4276b82ede197fcb">&#9670;&#160;</a></span>t_cose_param_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> * t_cose_param_find </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a parameter by label in linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The linked list to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>The label to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found parameter or NULL. </dd></dl>

</div>
</div>
<a id="ad3ccad34fa1eccefc8d2d939c3bb79bf" name="ad3ccad34fa1eccefc8d2d939c3bb79bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ccad34fa1eccefc8d2d939c3bb79bf">&#9670;&#160;</a></span>t_cose_param_find_alg_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t t_cose_param_find_alg_id </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>prot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the algorithm ID parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prot</td><td>Place to return whether ID is protected or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The algorithm ID or <a class="el" href="t__cose__standard__constants_8h.html#a5ad411c5f4d278338fdc4d8c50fd9626">T_COSE_ALGORITHM_NONE</a>.</dd></dl>
<p>This returns <a class="el" href="t__cose__standard__constants_8h.html#a5ad411c5f4d278338fdc4d8c50fd9626">T_COSE_ALGORITHM_NONE</a> on all errors including errors such as the parameter not being present, the parameter being of the wrong type. </p>

</div>
</div>
<a id="a9f74f4cc698ba68963cbe130be77da6c" name="a9f74f4cc698ba68963cbe130be77da6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f74f4cc698ba68963cbe130be77da6c">&#9670;&#160;</a></span>t_cose_param_find_alg_id_prot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t t_cose_param_find_alg_id_prot </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the protected algorithm ID parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The algorithm ID or <a class="el" href="t__cose__standard__constants_8h.html#a5ad411c5f4d278338fdc4d8c50fd9626">T_COSE_ALGORITHM_NONE</a>.</dd></dl>
<p>This returns <a class="el" href="t__cose__standard__constants_8h.html#a5ad411c5f4d278338fdc4d8c50fd9626">T_COSE_ALGORITHM_NONE</a> on all errors including errors such as the parameter not being present, the parameter being of the wrong type or the parameter not being protected. </p>

</div>
</div>
<a id="a612af7647cdaa346f74948d1c3334e36" name="a612af7647cdaa346f74948d1c3334e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612af7647cdaa346f74948d1c3334e36">&#9670;&#160;</a></span>t_cose_param_find_alg_id_unprot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t t_cose_param_find_alg_id_unprot </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the unprotected algorithm ID parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The algorithm ID or <a class="el" href="t__cose__standard__constants_8h.html#a5ad411c5f4d278338fdc4d8c50fd9626">T_COSE_ALGORITHM_NONE</a>.</dd></dl>
<p>This is for the unusual case were the algorithm ID must NOT be a protected parameter, such as for non-AEAD algorithms.</p>
<p>This returns <a class="el" href="t__cose__standard__constants_8h.html#a5ad411c5f4d278338fdc4d8c50fd9626">T_COSE_ALGORITHM_NONE</a> on all errors including errors such as the parameter not being present, the parameter being of the wrong type or the parameter being protected. </p>

</div>
</div>
<a id="a3f41b741c3745ae2b8611a6e8b75b9dc" name="a3f41b741c3745ae2b8611a6e8b75b9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f41b741c3745ae2b8611a6e8b75b9dc">&#9670;&#160;</a></span>t_cose_param_find_content_type_tstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct q_useful_buf_c t_cose_param_find_content_type_tstr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the text string content type parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content type or NULL_Q_USEFUL_BUF_C.</dd></dl>
<p>This returns NULL_Q_USEFUL_BUF_C on all errors including errors such as the parameter not being present, the parameter not being a string. It doesn't matter if the parameter is protected. or not. See also t_cose_param_find_content_type_int(). </p>

</div>
</div>
<a id="acd3d3bd6a38321cb4e792c325fceec51" name="acd3d3bd6a38321cb4e792c325fceec51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3d3bd6a38321cb4e792c325fceec51">&#9670;&#160;</a></span>t_cose_param_find_content_type_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t t_cose_param_find_content_type_uint </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the CoAP content type parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content type or <a class="el" href="t__cose__parameters_8h.html#a7c3f10122accf3f67342cfc1b01efe29">T_COSE_EMPTY_UINT_CONTENT_TYPE</a>.</dd></dl>
<p>This returns <a class="el" href="t__cose__parameters_8h.html#a7c3f10122accf3f67342cfc1b01efe29">T_COSE_EMPTY_UINT_CONTENT_TYPE</a> on all errors including errors such as the parameter not being present, the parameter not being an integer. It doesn't matter if the parameter is protected. or not. See also <a class="el" href="t__cose__parameters_8h.html#a3f41b741c3745ae2b8611a6e8b75b9dc" title="Find the text string content type parameter in a linked list.">t_cose_param_find_content_type_tstr()</a>. </p>

</div>
</div>
<a id="a1b9509bc8953a0787153594c7f058280" name="a1b9509bc8953a0787153594c7f058280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9509bc8953a0787153594c7f058280">&#9670;&#160;</a></span>t_cose_param_find_iv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct q_useful_buf_c t_cose_param_find_iv </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the initialization vector parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content type or NULL_Q_USEFUL_BUF_C.</dd></dl>
<p>This returns NULL_Q_USEFUL_BUF_C on all errors including errors such as the parameter not being present, the parameter not being a byte string. It doesn't matter if the parameter is protected. or not.</p>
<p>Note that the IV and partial IV parameters should not both be present. This does not check for that condition, but <a class="el" href="t__cose__parameters_8h.html#a69809f33c0f929be028849642c0b186c" title="Check parameter list, particularly for unknown critical parameters.">t_cose_params_check()</a> does and is called by functions like t_cose_sign_verify(). </p>

</div>
</div>
<a id="a5ff1cc0b353412a8cf5153bd970cd970" name="a5ff1cc0b353412a8cf5153bd970cd970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff1cc0b353412a8cf5153bd970cd970">&#9670;&#160;</a></span>t_cose_param_find_kid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct q_useful_buf_c t_cose_param_find_kid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the key ID (kid) parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content type or NULL_Q_USEFUL_BUF_C.</dd></dl>
<p>This returns NULL_Q_USEFUL_BUF_C on all errors including errors such as the parameter not being present, the parameter not being a byte string. It doesn't matter if the parameter is protected. or not. </p>

</div>
</div>
<a id="a60e9d48e702604801b14d2869948343e" name="a60e9d48e702604801b14d2869948343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e9d48e702604801b14d2869948343e">&#9670;&#160;</a></span>t_cose_param_find_partial_iv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct q_useful_buf_c t_cose_param_find_partial_iv </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the initialization vector parameter in a linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter_list</td><td>The parameter list to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content type or NULL_Q_USEFUL_BUF_C.</dd></dl>
<p>This returns NULL_Q_USEFUL_BUF_C on all errors including errors such as the parameter not being present, the parameter not being a byte string. It doesn't matter if the parameter is protected. or not.</p>
<p>Note that the IV and partial IV parameters should not both be present. This does not check for that condition, but <a class="el" href="t__cose__parameters_8h.html#a69809f33c0f929be028849642c0b186c" title="Check parameter list, particularly for unknown critical parameters.">t_cose_params_check()</a> does and is called by functions like t_cose_sign_verify(). </p>

</div>
</div>
<a id="a545129eca5ab20de90a5b3b4d3aff5ed" name="a545129eca5ab20de90a5b3b4d3aff5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545129eca5ab20de90a5b3b4d3aff5ed">&#9670;&#160;</a></span>t_cose_param_make_alg_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> t_cose_param_make_alg_id </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>alg_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> for algorithm ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alg_id</td><td>The COSE algorithm ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>.</dd></dl>
<p>This fills in all the elements in a struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> for an algorithm ID. In particular, it is always in the protected bucket and not critical (because all COSE implementations MUST understand this parameter).</p>
<p>struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> is usually used as a node in a linked list. This initializes the <code>next</code> pointer to <code>NULL</code>. If it's not the last item in a linked list it will have to be set. For example:</p>
<p>struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> params[2]; params[0] = t_cose_make_alg_id_parameter(cose_algorithm_id); params[1] = t_cose_make_kid_parameter(kid); params[0].next = &amp;params[1];</p>
<p>This is implemented as an inline function so it usually compiles down to some assignments (an inline function works in C and C++ where an initializer or a compound literal does not, particularly because there is a union involved and C++ can't initialize unions at all). </p>

</div>
</div>
<a id="a3f7a84ecdd2d3638ad43228271f40f6b" name="a3f7a84ecdd2d3638ad43228271f40f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7a84ecdd2d3638ad43228271f40f6b">&#9670;&#160;</a></span>t_cose_param_make_ct_tstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> t_cose_param_make_ct_tstr </td>
          <td>(</td>
          <td class="paramtype">struct q_useful_buf_c&#160;</td>
          <td class="paramname"><em>content_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> for a string content type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">content_type</td><td>String content type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>.</dd></dl>
<p>See <a class="el" href="t__cose__parameters_8h.html#a545129eca5ab20de90a5b3b4d3aff5ed">t_cose_param_make_alg_id()</a>. This works the same, except it is a string content type. </p>

</div>
</div>
<a id="a0291e4008cf4ee528dfe9fd0c854ed7c" name="a0291e4008cf4ee528dfe9fd0c854ed7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0291e4008cf4ee528dfe9fd0c854ed7c">&#9670;&#160;</a></span>t_cose_param_make_ct_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> t_cose_param_make_ct_uint </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>content_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> for an unsigned integer content typ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">content_type</td><td>Unsigned integer content type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>.</dd></dl>
<p>See <a class="el" href="t__cose__parameters_8h.html#a545129eca5ab20de90a5b3b4d3aff5ed">t_cose_param_make_alg_id()</a>. This works the same, except it is an unsigned integer content type. </p>

</div>
</div>
<a id="a6bfc6c35ec52d2ef7150bdfaa9d163d7" name="a6bfc6c35ec52d2ef7150bdfaa9d163d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfc6c35ec52d2ef7150bdfaa9d163d7">&#9670;&#160;</a></span>t_cose_param_make_iv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> t_cose_param_make_iv </td>
          <td>(</td>
          <td class="paramtype">struct q_useful_buf_c&#160;</td>
          <td class="paramname"><em>iv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> for an initialization vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>.</dd></dl>
<p>See <a class="el" href="t__cose__parameters_8h.html#a545129eca5ab20de90a5b3b4d3aff5ed">t_cose_param_make_alg_id()</a>. This works the same, except it is for an initialization vector. </p>

</div>
</div>
<a id="a81088452143eca66114cd3ccfc28aa29" name="a81088452143eca66114cd3ccfc28aa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81088452143eca66114cd3ccfc28aa29">&#9670;&#160;</a></span>t_cose_param_make_kid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> t_cose_param_make_kid </td>
          <td>(</td>
          <td class="paramtype">struct q_useful_buf_c&#160;</td>
          <td class="paramname"><em>kid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> for a key identifier (kid).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kid</td><td>Key identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>.</dd></dl>
<p>See <a class="el" href="t__cose__parameters_8h.html#a545129eca5ab20de90a5b3b4d3aff5ed">t_cose_param_make_alg_id()</a>. This works the same, except it is for a key ID (kid). </p>

</div>
</div>
<a id="ad15cddff6d474ac7d7d0f1d85a1e7b7a" name="ad15cddff6d474ac7d7d0f1d85a1e7b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15cddff6d474ac7d7d0f1d85a1e7b7a">&#9670;&#160;</a></span>t_cose_param_make_partial_iv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> t_cose_param_make_partial_iv </td>
          <td>(</td>
          <td class="paramtype">struct q_useful_buf_c&#160;</td>
          <td class="paramname"><em>iv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> for an partial initialization vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Partial initialization vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>.</dd></dl>
<p>See <a class="el" href="t__cose__parameters_8h.html#a545129eca5ab20de90a5b3b4d3aff5ed">t_cose_param_make_alg_id()</a>. This works the same, except it is for a partial initialization vector. </p>

</div>
</div>
<a id="ab14704cc3462c82fedfcc45682af0829" name="ab14704cc3462c82fedfcc45682af0829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14704cc3462c82fedfcc45682af0829">&#9670;&#160;</a></span>t_cose_param_special_decode_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a> t_cose_param_special_decode_cb </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QCBORDecodeContext *&#160;</td>
          <td class="paramname"><em>cbor_decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of callback to decode a special parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_context</td><td>Context for callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbor_decoder</td><td>QCBOR decoder to pull from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parameter</td><td>On input, label and other. On output the decoded value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">T_COSE_SUCCESS</td><td>Decoded and input consumed </td></tr>
    <tr><td class="paramname">T_COSE_DECLINE</td><td>Not decoded and input was NOT consumed </td></tr>
    <tr><td class="paramname">other</td><td>Any other error will stop the decode and return that error up to top-level message decode.</td></tr>
  </table>
  </dd>
</dl>
<p>This is called back from t_cose_decode_headers() when a parameter that is not an integer or string is encountered.</p>
<p>On input, the label, protected, critical and value_type are set based on peeking at the first data item in the header. The value is not set and none of the items in the parameter have been consumed.</p>
<p>A callback can decided not to process the parameter by checking the parameter label and such passed in. If it ia not to be process return T_COSE_ERR_DECLINE. The parameter will be ignored. If a critical parameter is declined, this will be noticed and the COSE message processing will error out with <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97a97e707b3428ea321bdeb78a1464b3d4c">T_COSE_ERR_UNKNOWN_CRITICAL_PARAMETER</a>.</p>
<p>For a successful decode, all of the CBOR items for the parameter must be consumed from the cbor decoder. T_COSE_SUCCESS should be returned. The decoded value(s) is(are) put into <code>parameter.value</code>. Any of the the members of <code>parameter.value</code> may be used, particularly <code>parameter.value.special_decode</code>.</p>
<p>For an unsuccesful decode return an appropriate error like T_COSE_ERR_NOT_WELL_FORMED. It will halt processing of the message flow and be returned to the top level call.</p>
<p>Unlike t_cose_special_param_encode_cb() only one of these may be set. Implementation of this switche on the label to know which parameter to output. </p>

</div>
</div>
<a id="a5d3282978b24d425b9a1066e050e08c9" name="a5d3282978b24d425b9a1066e050e08c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3282978b24d425b9a1066e050e08c9">&#9670;&#160;</a></span>t_cose_param_special_encode_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a> t_cose_param_special_encode_cb </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QCBOREncodeContext *&#160;</td>
          <td class="paramname"><em>cbor_encoder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of callback to output the encoded CBOR of a special parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>A single parameter to encode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbor_encoder</td><td>The encoder instance to output to.</td></tr>
  </table>
  </dd>
</dl>
<p>A callback pointer of this type is placed in struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a>. It is called back when t_cose_encode_headers() gets to encoding the particular parameter. It is typically used for encoding special parameters that are not integers or strings, but can be used for them too. For most use cases, this is not needed.</p>
<p>When called it should output the CBOR for the header parameter to the CBOR encoder context including the header label.</p>
<p>If this returns an error, encoding of the COSE message will stop and error out with the error it returned.</p>
<p>If desired there can be several implementations of this for several different parameters or types of parameters. </p>

</div>
</div>
<a id="a5421930f23872fb1cbc2cba4c48e6774" name="a5421930f23872fb1cbc2cba4c48e6774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5421930f23872fb1cbc2cba4c48e6774">&#9670;&#160;</a></span>t_cose_params_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void t_cose_params_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> **&#160;</td>
          <td class="paramname"><em>existing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>to_be_appended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append one list of parameters to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">existing</td><td>A pointer to the head of a parameter linked list to which <code>to_be_appended</code> is added to the end or a pointer to <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_be_appended</td><td>A parameter linked list which it is to added.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>*existing</code> is not <code>NULL</code>, this finds the end of <code>*existing</code> and sets the <code>next</code> member in the last node to <code>to_be_appended</code>. If it is <code>NULL</code>, this just assigns <code>to_be_appended</code> to <code>*existing</code>.</p>
<p><code>to_be_appended</code> may be <code>NULL</code>. </p>

</div>
</div>
<a id="a69809f33c0f929be028849642c0b186c" name="a69809f33c0f929be028849642c0b186c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69809f33c0f929be028849642c0b186c">&#9670;&#160;</a></span>t_cose_params_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a> t_cose_params_check </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check parameter list, particularly for unknown critical parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>Linked list of parameters to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">T_COSE_SUCCESS</td><td>Nothing wrong in parameter list. </td></tr>
    <tr><td class="paramname">T_COSE_ERR_UNKNOWN_CRITICAL_PARAMETER</td><td>A parameter was marked critical that is not one of the standard common parameters handled by t_cose (T_COSE_HEADER_PARAM_ALG through T_COSE_HEADER_PARAM_PARTIAL_IV). </td></tr>
    <tr><td class="paramname">T_COSE_ERR_DUPLICATE_PARAMETER</td><td>Both IV and partial IV parameters are present</td></tr>
  </table>
  </dd>
</dl>
<p>This is used by t_cose_sign_verify() and such to check there are no critical parameters except that it allows the standard parameters that are decoded by default to be marked critical.. </p>

</div>
</div>
<a id="a95d908ec137d12d9bd74cec2be72e536" name="a95d908ec137d12d9bd74cec2be72e536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d908ec137d12d9bd74cec2be72e536">&#9670;&#160;</a></span>t_cose_params_common()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97">t_cose_err_t</a> t_cose_params_common </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structt__cose__parameter.html">t_cose_parameter</a> *&#160;</td>
          <td class="paramname"><em>decoded_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structt__cose__parameters.html">t_cose_parameters</a> *&#160;</td>
          <td class="paramname"><em>returned_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in structure with common header parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decoded_params</td><td>Linked list of decoded parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returned_params</td><td>A filled in structure with the common header parameters.</td></tr>
  </table>
  </dd>
</dl>
<p><code>decoded_params</code> is traversed and any of the common headers parameters found in it are filled into <code>returned_parameters</code>. Unknown header parameters are ignored, even critical ones.</p>
<p>This is called by <a class="el" href="t__cose__sign1__verify_8h.html#ab14a59bbe3e640de21ea4f8e34abf3c9" title="Verify a COSE_Sign1.">t_cose_sign1_verify()</a> internally to convert the linked list parameters format in t_cose 2.x to <a class="el" href="structt__cose__parameters.html">t_cose_parameters</a> used in t_cose 1.x.</p>
<p>Note that the parameters processed by this are the set defined in section 3.1 of RFC 9052 and are sole parameters used in RFC 9052 and 9053.</p>
<p>This will return <a class="el" href="t__cose__common_8h.html#a469580b586841b779bbdc430d3a0dd97a8f118d6979c8c81cef8c6250e969bed9">T_COSE_ERR_DUPLICATE_PARAMETER</a> if both iv and partial_iv parameters are present. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
